# Solution to Matasano Crypto Challenge 3.24 http://cryptopals.com/sets/3/challenges/24/
# Create a stream cipher from an MT19337 RNG and break it
# Use stream cipher to create password reset token; use attack to validate token

import crypto21
import random
import time
from crypto11 import generate_aes_key

def mt_stream(seed, text):
	# Generate a keystream from MT19337 RNG outputs
	# Encrypt or decrypt (symmetric function) a text against stream
	stream_array = [] # testing
	result_text = ''
	crypto21.initialize_generator(seed)

	i = 0
	while i < len(text):
		current_prng = crypto21.extract_number()
		current_byte = current_prng % 255
		stream_array.append(current_byte) # testing
		byte_output = current_byte ^ ord(text[i])
		result_text += chr(byte_output)
		i += 1

	return result_text.encode('hex')

def prepend_random(known_text):
	# This function simulates an unknown plaintext and prepends it to a known text
	random_plaintext = ''
	length = random.randint(14, 14*8)

	for x in xrange(length):
		random_plaintext += chr(random.randint(0,255))

	modified_text = random_plaintext + known_text
	return modified_text

def recover_prng(known_text, raw_ciphertext):
	# XOR the known string against the last corresponding portion of the ciphertext
	# Return an array of the recovered XOR values (recovered keystream)
	recovered_prng_output = ''
	recovered__array = []
	known_text_ciphertext_block = raw_ciphertext[len(raw_ciphertext) - len(known_text):]

	i = 0
	while i < len(known_text):
		stream_byte = ord(known_text[i]) ^ ord(known_text_ciphertext_block[i])
		recovered__array.append(stream_byte)
		recovered_prng_output += chr(stream_byte)
		i += 1

	return recovered__array

def recover_seed(unknown_stream_length, recovered_array, min_range, max_range):
	# Test the recovered keystream values against all 16-bit integer seeds for the RNG
	seed_match = 0 # Function returns 0 if no match found

	for x in xrange(min_range, max_range):
		crypto21.initialize_generator(x)
		# Dump the number of keystream bytes that correspond to the portion of the ciphertext
		# generated by the prepended plaintext
		for y in xrange(unknown_stream_length):
			garbage_value = crypto21.extract_number() % 255
		# After dumping outputs, check known outputs against RNG outputs
		i = 0
		while i < len(recovered_array):
			test_value = crypto21.extract_number() % 255
			if recovered_array[i] == test_value:
				i += 1
			else:
				break

		if i == len(recovered_array):
			seed_match = x
			return seed_match

	return seed_match

def generate_reset_token(token_text):
	# Seed RNG with current time and XOR known string w/ RNG output to generate password reset token
	seed = int(time.time())
	reset_token = mt_stream(seed, token_text)
	return reset_token

def validate_reset_token(token_text, reset_token):
	# Test password reset token against seeds from past 24 hour window
	raw_reset_token = reset_token.decode('hex')
	recovered_array = recover_prng(token_text, raw_reset_token)
	current_time = int(time.time())
	start_time = current_time - (24*60*60)
	recovered_seed = recover_seed(0, recovered_array, start_time, current_time)

	if (recovered_seed > start_time) and (recovered_seed < current_time):
		return True
	else:
		return False

if __name__ == '__main__':
	"""
	# Seed RNG with some 16 bit integer then recover the seed
	seed = random.randint(32768, 65535)
	known_text = 'A'*14
	modified_text = prepend_random(known_text)

	ciphertext = mt_stream(seed, modified_text)
	raw_ciphertext = ciphertext.decode('hex')

	recovered_array = recover_prng(known_text, raw_ciphertext)
	unknown_stream_length = len(raw_ciphertext) - len(known_text)
	recovered_seed = recover_seed(unknown_stream_length, recovered_array, 32768, 65535)
	print recovered_seed
	"""
	# Generate password reset token and validate
	token_text = 'A'*8
	reset_token = generate_reset_token(token_text)
	print reset_token
	time.sleep(1)
	print validate_reset_token(token_text, reset_token)



